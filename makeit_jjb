#!/usr/bin/python

######################################################################
#
# makeit -- build RADS
#
# Right now, the directory structure is relatively flat:
# 
# src/
# src/rads -- all cython and python files
# src/rads/maps -- where the maps go
# src/cpp -- all c++ files
#
######################################################################

from fabricate import *
import sys, os, stat, commands

def list_dirs(path):
	"""Returns a list of all top-level subdirectories in directory 'path'"""
	return [ name for name in os.listdir(path) if os.path.isdir(os.path.join(path, name)) ]

project_dir = '/Users/jberwald/Dropbox/Projects/entropy/rads/'
profil_path = project_dir+'Profil-2.0.8/'
cython_path = 'cython'
sage_cython_include = '/usr/local/share/sage-4.2-linux-ubuntu9.10-i686-Linux/devel/sage-main/'
# sage_c_include = '/usr/local/share/sage-4.2-linux-ubuntu9.10-i686-Linux/devel/sage-main/c_lib/include/'

rads_dirs = list_dirs('src/rads')+['','../cpp/']
rads_includes = ['-I'+project_dir+'src/rads/'+folder for folder in rads_dirs]
profil_includes = ['-I'+profil_path+'include/']

comp1 = """gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -fPIC
-I/usr/local/lib/python2.7/dist-packages/numpy/core/include/
-I/usr/local/lib/python2.7/dist-packages/Cython/Includes/libc/
-I/usr/local/lib/python2.7/dist-packages/Cython/Includes/libcpp/
-I. -I/usr/include/python2.7
-c""".split() + rads_includes + profil_includes
comp2 = ["-o"]
comp3 = "-O3 -w".split()

link1 = "g++ -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions".split()
link2 = "-lProfil -llr -lBias -o".split()
link3 = ["-g","-L"+profil_path+"lib/"]

clink1 = "g++"
clink2 = "-lProfil -llr -lBias -o".split()
clink3 = ["-g","-L"+profil_path+"lib/"]


def compile_cpp(inputs,output):
	run(comp1,inputs,comp2,output,comp3)

def compile_cython(inputs,output):
	run(cython_path, '-I'+sage_cython_include, rads_includes,
		'-a', '--cplus', inputs, '-o', output)

def link(inputs,output):
	run(link1,inputs,link2,output,link3)

def link_cpp(inputs,output):
	run(clink1,inputs,clink2,output,clink3)

dependencies = { # dependencies for cython (or c++!) files
	'graphs': [],
	'cyboxset': ['box','boxset'],
	'cytree': ['tree','box','boxset','treedata'],
	'cyutils': ['box'],
	'cymapper': ['mapper','box','boxset'],
	'cycombenc': ['tree','treedata','mapper','box','boxset'],
	'treetest': ['tree','treedata','box','boxset'],
	'debugtree': ['tree','treedata','box','boxset'],
	}

cpp_progs = ['treetest','debugtree'] # c++ programs
cpp_source_dir = 'src/cpp/' # look for c++ files here (in the current dir)
cpp_dest_dir = 'cpp/' # compile them here (in the build dir)

def cpp_deps(path):
	"""Returns a list of (source,dest) pairs for each dependency of
	'path', as given by 'dependencies'.  'source' is the source path of the
	dependency, and 'dest' is where it should be compiled to.  If the
	file is not in dependencies, interpret it as a map and deal with it
	accordingly."""
	parts = path.split('/')
	name = parts[-1]
	if name in dependencies:
		# (source, dest)
		return [(cpp_source_dir+s,cpp_dest_dir+s) for s in dependencies[name]]
	
	# otherwise, must be a map file; automagically find the corresponding cpp file!
	return [('src/rads/maps/'+path+'_cpp',
			 cpp_dest_dir+path+'_autogenerated_mapfile')] # (source, dest)


# scan the source directory for extension files, converting
# them to extension names in dotted notation
def scandir(dir, files=[]):
    for file in os.listdir(dir):
        path = os.path.join(dir, file)
        if os.path.isfile(path) and path.endswith(".pyx"):
            files.append(path.replace(os.path.sep, ".")[:-4])
        elif os.path.isdir(path):
            scandir(path, files)
    return files


tmp_dir = 'build/temp.linux-i686-2.7/'
lib_dir = 'build/lib.linux-i686-2.7/'

def build_cpp_deps(f):
	"""Builds each dependency of f (not including f).  Returns the
	list of destinations so that the linker can find where these ended
	up."""
	deps = cpp_deps(f) # doesn't include f
	for (source,dest) in deps:
		compile_cpp(source+'.cpp',tmp_dir+dest+'.o')
	return [cpp_dest_dir+f]+[d[1] for d in deps] # the destinations, include f here


def build_cyfile(extName):
	cypath = extName.replace('.', os.path.sep) # path to cython file
	cyfile = cypath.split('/')[-1]  # just the file name
	finalcypath = cypath.replace('src/','') # the final resting place = rads/../..

	# compile to temp dir, but flat (notice cyfile instead of cypath)
	compile_cython(cypath+'.pyx', tmp_dir+cyfile+'_from_cython.cpp')
	compile_cpp(tmp_dir+cyfile+'_from_cython.cpp', tmp_dir+cpp_dest_dir+cyfile+'.o')

	deps = build_cpp_deps(cyfile) # c++ dependencies, including self

	link([tmp_dir+d+'.o' for d in deps],lib_dir+finalcypath+'.so')

def build_cpp(name):
	"""Build a c++ file."""
	compile_cpp(cpp_source_dir+name+'.cpp', tmp_dir+cpp_dest_dir+name+'.o')
	deps = build_cpp_deps(name)
	link_cpp([tmp_dir+d+'.o' for d in deps],lib_dir+name)


def build():
	print "in build"
	os.chdir('src' )
	print "running buildpy..."
	run('python ../buildpy.py build --build-base=../build'.split())
	print "done"
	os.chdir('..')
	files = scandir("src/rads")
	print files
	for name in files:
		build_cyfile(name)
	for name in cpp_progs:
		build_cpp(name)

def makedirs():
	run(['mkdir','build',tmp_dir,tmp_dir+'src/'])
	run(['mkdir',tmp_dir+cpp_dest_dir,tmp_dir+'henon_cpp/',tmp_dir+'maps/'])

def test():
	os.chdir(lib_dir)
	run('ipython', '-pylab', 'rads/test_tree.py')
	
def clean():
	run('rm -r build'.split())
	autoclean()

main()

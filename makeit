#!/usr/bin/python

######################################################################
#
# makeit -- build RADS
#
# Right now, the directory structure is relatively flat:
# 
# src/
# src/rads -- all cython and python files
# src/rads/maps -- where the maps go
# src/cpp -- all c++ files
#
######################################################################

from fabricate import *
import sys, os, stat, commands
from config import config_dirs, include_dirs
from shutil import copytree, ignore_patterns
### EXAMPLE: copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))

def list_dirs(path):
	"""Returns a list of all top-level subdirectories in directory 'path'"""
	return [ name for name in os.listdir(path) if os.path.isdir(os.path.join(path, name)) ]

rads_dirs = list_dirs('src/rads')+['','../cpp/']
includes = [config_dirs['base']+'src/rads/'+folder for folder in rads_dirs]
includes += include_dirs.values()

comp1 = """gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -fPIC
-I/usr/local/lib/python2.7/dist-packages/numpy/core/include/
-I/usr/local/lib/python2.7/dist-packages/Cython/Includes/libc/
-I/usr/local/lib/python2.7/dist-packages/Cython/Includes/libcpp/
-I. -I/usr/include/python2.7
-c""".split() + ['-I'+inc for inc in includes]
comp2 = ["-o"]
comp3 = "-O3 -w".split()

link1 = "g++ -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions".split()
link2 = "-lProfil -llr -lBias -o".split()
link3 = ["-g","-L"+config_dirs['profil']+"lib/"]

clink1 = "g++"
clink2 = "-lProfil -llr -lBias -o".split()
clink3 = ["-g","-L"+config_dirs['profil']+"lib/"]


def compile_cpp(inputs,output):
	run(comp1,inputs,comp2,output,comp3)

def compile_cython(inputs,output):
	run(config_dirs['cython'], ['-I'+inc for inc in includes],
		'-a', '--cplus', inputs, '-o', output)

def link(inputs,output):
	run(link1,inputs,link2,output,link3)

def link_cpp(inputs,output):
	run(clink1,inputs,clink2,output,clink3)

dependencies = { # dependencies for cython (or c++!) files
	'cyboxset': ['box','boxset'],
	'cytree': ['tree','box','boxset','treedata'],
	'cyutils': ['box'],
	'cymapper': ['mapper','box','boxset'],
	'cycombenc': ['tree','treedata','mapper','box','boxset'],
	'treetest': ['tree','treedata','box','boxset'],
	'debugtree': ['tree','treedata','box','boxset'],
}

cpp_progs = ['treetest','debugtree'] # c++ programs


# scan the source directory for extension files, converting
# them to extension names in dotted notation
def scandir(dir, files=[], ext='.py'):
	"""
	Return all paths (dir/dir2/dir3/file) of files in 'dir' (including subdirectories) with extension 'ext'
	"""
	for file in os.listdir(dir):
		path = os.path.join(dir, file)
		if os.path.isfile(path) and path.endswith( ext ):
			print path
			# files.append(path.replace(os.path.sep, '.')[:-len(ext)-1])
			files.append(path[:-len(ext)]) # kill extension
		elif os.path.isdir(path):
			scandir(path, files, ext)
	return files


tmp_dir = 'build/tmp.linux-i686-2.7/'
lib_dir = 'build/lib.linux-i686-2.7/'
map_dir = 'src/rads/maps'
cpp_source_dir = 'src/cpp/' # look for c++ files here (in the current dir)
cpp_object_dir = tmp_dir+'cpp/' # compile them here (in the build dir)

def build_cpp_deps(f):
	"""
	Builds each dependency of f (not including f).	Returns the
	list of destinations so that the linker can find where these ended
	up.
	"""
	name = f.split('/')[-1]				# name.cpp (or name.pyx)
	if name not in dependencies:
		return []							# nothing to do here...

	for dep in dependencies[name]:
		compile_cpp(cpp_source_dir+dep+'.cpp',cpp_object_dir+dep+'.o')
	objects = [cpp_object_dir + d for d in [f]+dependencies[name]]
	return objects # the destinations, include f here


def build_cyfile(sourcepath):
	"""
	NOTE: using a flat namespace for Cython for right now to easy the dependencies...
	1. Compile (Cython)
		 src/rads/...../file.pyx --> <cpp_source_dir>/file_from_cython.cpp
		 
	2. Compile (C++)
		 <cpp_source_dir>/file_from_cython.cpp --> <cpp_object_dir>/file.o
		 
	3. Look up dependencies[file] and compile each of those
		 <cpp_object_dir>/dep.o
		 
	4. Finally, link all of the above
		 <lib_dir>/rads/...../file.so
	"""
	filename = sourcepath.split(os.path.sep)[-1]			   # filename.pyx
	tempfile = tmp_dir+filename+'_from_cython.cpp' # the temp cpp file name
	finalpath = lib_dir+sourcepath.replace('src/','') # the final resting place = rads/../..

	# compile to temp dir, but flat (notice tempfile instead of sourcepath)
	compile_cython(sourcepath+'.pyx', tempfile)
	compile_cpp(tempfile, cpp_object_dir+filename+'.o')
	deps = build_cpp_deps(filename) # c++ dependencies, including self
	
	objects = [d+'.o' for d in deps]
	link(objects, finalpath+'.so')


def build_map(sourcepath):
	"""
	NOTE: using a flat namespace for Cython for right now to easy the dependencies...
	1. Compile (Cython, C++)
		 src/rads/maps/map.pyx --> <cpp_source_dir>/map_cython_mapfile.cpp
		 <cpp_source_dir>/map_cython_mapfile.cpp --> <cpp_object_dir>/map_cython_mapfile.o

	2. Compile (C++)
		 src/rads/maps/map_cpp.cpp --> <cpp_object_dir>/map_cpp_mapfile.o

	3. Finally, link all of the above
		 <lib_dir>/rads/maps/map.so
	"""
	filename = sourcepath.split(os.path.sep)[-1]			   # filename.pyx
	finalpath = lib_dir+sourcepath.replace('src/','') # the final resting place = rads/../..
	cython_cpp = tmp_dir+filename+'_cython_mapfile.cpp'
	cython_o = cpp_object_dir+filename+'_cython_mapfile.o'
	cpp_o = cpp_object_dir+filename+'_cpp_mapfile.o'
	
	compile_cython(sourcepath+'.pyx', cython_cpp)
	compile_cpp(cython_cpp, cython_o)
	compile_cpp(sourcepath+'_cpp.cpp', cpp_o)

	link([cython_o, cpp_o], finalpath+'.so')


def build_cpp(name):
	"""Build a c++ file."""
	compile_cpp(cpp_source_dir+name+'.cpp', cpp_object_dir+name+'.o')
	deps = build_cpp_deps(name)
	link_cpp([d+'.o' for d in deps],lib_dir+name)


def build():
	# copy python files over, preserving directory structure
	#	copytree('src/rads/', lib_dir+'rads/', ignore=ignore_patterns('*.pyx', '*.pyd', '*.cpp', '*.h', '*~'))	
	os.chdir('src' )
	run('python ../buildpy.py build --build-base=../build'.split())
	os.chdir('..')
	files = scandir('src/rads',ext='.pyx')
	print files

	for path in files:
		if path.startswith(map_dir):	# treat maps differently
			build_map(path)
		else:
			build_cyfile(path)

	for name in cpp_progs:
		build_cpp(name)

def makedirs():
	run(['mkdir','build',tmp_dir,tmp_dir+'src/',cpp_object_dir])

def test():
	os.chdir(lib_dir)
	run('ipython', '-pylab', 'rads/test_tree.py')
	
def clean():
	run('rm -r build'.split())
	autoclean()
	makedirs()

main()
